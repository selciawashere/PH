-- Started On June 7 2025
-- Scripted By dragon
-- Infinite Money (Takes 2-3 Minutes)
-- BYPASSED ANTICHEAT 
-- ADDED FLY (BYPASSED)
local repo = 'https://raw.githubusercontent.com/selciawashere/PH/refs/heads/main/UILIBMobile'

print("Mobile UI Loaded")


local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/selciawashere/PH/refs/heads/main/ThemeManagerMobile'))()
local SaveManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/selciawashere/PH/refs/heads/main/SaveManagerMobile'))()
local Window = Library:CreateWindow({
    Title = 'Proximity Hub [V.1.0.1]| Tha Bronx 3 | ' .. (identifyexecutor and identifyexecutor() or "Unknown"),
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = false,
    NotifySide = "Left",
})

local Tabs = {
    Main = Window:AddTab("Main"),
    Autofarm = Window:AddTab("AutoFarm"),
    Player = Window:AddTab("Player"),
    Visuals = Window:AddTab("Visuals"),
    Combat = Window:AddTab("Combat"),
    ['Settings'] = Window:AddTab('Settings'),
}
local ATMBank = Tabs.Main:AddLeftGroupbox('ATM / Bank')
local Teleports = Tabs.Main:AddLeftGroupbox("Teleport")
local Vuln = Tabs.Main:AddRightGroupbox("Vulnerabilities")
local QuickShop = Tabs.Main:AddRightGroupbox('Quick Shops')
local ShopGui = Tabs.Main:AddLeftGroupbox("Shop Gui's")

local AutofarmS = Tabs.Autofarm:AddLeftGroupbox("Auto Farm Money")

local Playerr = Tabs.Player:AddRightGroupbox("Movements")
local ExtraBox = Tabs.Player:AddLeftGroupbox("Player Stats & Setting")
local Animations = Tabs.Player:AddRightGroupbox("Animation")


local ESPSettings = Tabs.Visuals:AddLeftGroupbox("ESP Settings")
local ESPBoxes = Tabs.Visuals:AddLeftGroupbox("ESP Boxes")
local ESPTracers = Tabs.Visuals:AddRightGroupbox("ESP Tracers")
local ESPNames = Tabs.Visuals:AddLeftGroupbox("ESP Names")
local ESPHealthBars = Tabs.Visuals:AddRightGroupbox("ESP Health")
local ESPDistance = Tabs.Visuals:AddLeftGroupbox("ESP Distance")
local VisualsTab = Tabs.Visuals:AddRightGroupbox("Ambient Surroundings")

local Aimbot = Tabs.Combat:AddLeftGroupbox("Aimbot Tab")
local Silent = Tabs.Combat:AddRightGroupbox("Silent Aim")
local GunMods = Tabs.Combat:AddRightGroupbox("Gun Modz")
local Extra = Tabs.Combat:AddLeftGroupbox("Kill Aura")
local Hitboxes = Tabs.Combat:AddRightGroupbox("Hitbox Config")

local MenuGroupRight = Tabs['Settings']:AddRightGroupbox('Server')
local MenuGroup = Tabs['Settings']:AddRightGroupbox('Menu')


-- Variables/Services Cleaned By dragon
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")


local lastDeathPosition = nil
local autoTPEnabled = false
local deathConnection
local charAddedConn
 
local teamCheck = false
local highlightEnabled = false
local checkIfAlive = true
local fovRadius = 90
local smoothing = 1.1
local predictionFactor = 0.08
local lockPart = "HumanoidRootPart"


_G.AimbotPowerEnabled = false
_G.AimbotKeyName = "E"
_G.FOVCircleVisible = false
_G.RainbowFOV = false
_G.HeadSize = 1
_G.Disabled = true
_G.UseCustomHitbox = true
_G.HeadSize = 50
_G.CustomHitboxColor = Color3.fromRGB(0, 0, 255)
_G.CustomHitboxTransparency = 0.7

getgenv().highlight = false
getgenv().wallbang = false
getgenv().randomredire = false
getgenv().killaurahigh = false
getgenv().auraenabled = false
getgenv().beam = true
getgenv().cooldown = 0.1
getgenv().damage = 100
getgenv().hitpart = "Head"
getgenv().color = Color3.fromRGB(0, 0, 255)
getgenv().rainbowbeam = false


-- ATMBanks
ATMBank:AddInput('[Cash Amount]', {
    Default = '[Cash Amount]',
    Numeric = true,
    Finished = true,
    Text = 'Cash Amount',
    Tooltip = nil,
    Placeholder = 'Enter cash amount',
    Callback = function(text)
        local amount = tonumber(text)
        if not amount then print("Invalid input for cash amount.") return end
        atmbankamount = amount
    end
})

ATMBank:AddButton('Deposit', function()
    game:GetService("ReplicatedStorage"):WaitForChild("BankAction"):FireServer("depo", atmbankamount)
end)

ATMBank:AddButton('Withdraw', function()
    game:GetService("ReplicatedStorage"):WaitForChild("BankAction"):FireServer("with", atmbankamount)
end)

ATMBank:AddButton('Drop', function()
    game:GetService("ReplicatedStorage"):WaitForChild("BankProcessRemote"):InvokeServer("Drop", atmbankamount)
end)

-- ShopGuis

ShopGui:AddButton('Shop GUI', function()
    local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
    if playerGui:FindFirstChild("ShopGui") then
        playerGui["ShopGui"].Enabled = true
    else
        Library:Notify('Shop GUI not found', 3)
    end
end)

ShopGui:AddButton('Gun Market', function()
    local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
    if playerGui:FindFirstChild("Bronx Market 2") then
        playerGui["Bronx Market 2"].Enabled = true
    else
        Library:Notify('Gun Market GUI not found', 3)
    end
end)
ShopGui:AddButton('Exotic Shop', function()
    local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
    if playerGui:FindFirstChild("Exotic Shop") then
        playerGui["Exotic Shop"].Enabled = true
    else
        Library:Notify('Exotic Shop GUI not found', 3)
    end
end)

ShopGui:AddButton('Tattoo Shop', function()
    local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
    if playerGui:FindFirstChild("Bronx TATTOOS") then
        playerGui["Bronx TATTOOS"].Enabled = true
    else
        Library:Notify('Bronx tattoo GUI not found', 3)
    end
end)

ShopGui:AddButton('Pawn Shop', function()
    local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
    if playerGui:FindFirstChild("Bronx PAWNING") then
        playerGui["Bronx PAWNING"].Enabled = true
    else
        Library:Notify('Bronx pawn GUI not found', 3)
    end
end)

ShopGui:AddButton('Trunk Storage', function()
    local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
    if playerGui:FindFirstChild("TRUNK STORAGE") then
        playerGui["TRUNK STORAGE"].Enabled = true
    else
        Library:Notify('Trunk Storage GUI not found', 3)
    end
end)


local locations = {
    ["üî´ Gunshop"] = Vector3.new(92972.28125, 122097.953125, 17022.783203125),
    ["üî´ Gunshop 2"] = Vector3.new(66202, 123615.7109375, 5749.81591796875),
    ["üî´ Gunshop 3"] = Vector3.new(60819.78515625, 87609.140625, -347.30889892578125),
    ["üì¶ Safe Items"] = Vector3.new(68514.8984375, 52941.5, -796.0919799804688),
    ["ü¶∫ Construction Site"] = Vector3.new(-1731.8306884765625, 370.8122863769531, -1176.8387451171875),
    ["üíé Ice Box"] = Vector3.new(-249.5778045654297, 283.5154113769531, -1256.6583251953125),
    ["‚åö Frozen Shop"] = Vector3.new(-225.86630249023438, 283.84869384765625, -1169.9425048828125),
    ["üëï Drip Store"] = Vector3.new(67462.6953125, 10489.0322265625, 549.5894775390625),
    ["üèß Bank"] = Vector3.new(-240.43710327148438, 283.6267395019531, -1214.412841796875),
    ["üè™ Pawn Shop"] = Vector3.new(-1049.64306640625, 253.53065490722656, -814.2697143554688),
    ["üè° Penthouse"] = Vector3.new(-143, 417, -574),
    ["üçó Chicken Wings"] = Vector3.new(-957.9141845703125, 253.53065490722656, -815.9442138671875),
    ["üõí Deli"] = Vector3.new(-724, 253, -677),
    ["üçï Dominos"] = Vector3.new(-771.4325561523438, 253.22897338867188, -956.450927734375),
    ["üöó Car Dealer"] = Vector3.new(-410.5223083496094, 253.2564697265625, -1245.553955078125),
    ["üõ†Ô∏è Bank Tools"] = Vector3.new(-387, 340, -559),
    ["üè® Hotel"] = Vector3.new(-1000, 253, -565),
    ["üé¨ Studio"] = Vector3.new(93411, 14485, 570),
    ["üß∫ Laundromat"] = Vector3.new(-965, 254, -684),
    ["üëÆ NYPD Gear Room"] = Vector3.new(-98, 285, -680),
    ["üéí Backpack Shop"] = Vector3.new(-672, 254, -682),
}

function tableKeys(tbl)
    local keys = {}
    for key, _ in pairs(tbl) do
        table.insert(keys, key)
    end
    return keys
end

getgenv().SwimMethod = false
local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
local screenGui = playerGui:FindFirstChild("TeleportGui") or Instance.new("ScreenGui")
screenGui.Name = "TeleportGui"
screenGui.Parent = playerGui
screenGui.ResetOnSpawn = false

local SelectedLocation = nil
local blackScreen = Instance.new("Frame")
blackScreen.Size = UDim2.new(1, 0, 1, 0)
blackScreen.Position = UDim2.new(0, 0, 0, 0) 
blackScreen.BackgroundColor3 = Color3.new(0, 0, 0)
blackScreen.BackgroundTransparency = 1
blackScreen.ZIndex = 9999
blackScreen.Parent = screenGui

local TweenService = game:GetService("TweenService")

function animateBlackScreen(fadeIn)
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
    local goal = {BackgroundTransparency = fadeIn and 0 or 1}
    local tween = TweenService:Create(blackScreen, tweenInfo, goal)
    tween:Play()
    tween.Completed:Wait()
end

function teleportToLocation()
    if not SelectedLocation then
        Library:Notify("Error: No location selected!", 3)
        return
    end
    local character = game.Players.LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not humanoidRootPart then
        Library:Notify("Error: Invalid Teleport Location!", 3)
        return
    end

    animateBlackScreen(true)

    getgenv().SwimMethod = true
    task.wait(1)

    local targetPosition = SelectedLocation
    humanoidRootPart.CFrame = CFrame.new(targetPosition)

    getgenv().SwimMethod = false
    
    animateBlackScreen(false)
    
    Library:Notify("Teleported to location", 3)
end
-- Teleportss
local locationDropdown = Teleports:AddDropdown('LocationDropdown', {
    Values = tableKeys(locations),
    Default = "",
    Multi = false,
    Text = 'Select Location',
    Callback = function(selectedLocation)
        if locations[selectedLocation] then
            SelectedLocation = locations[selectedLocation]
            Library:Notify("Location Found: " .. selectedLocation, 3)
            teleportToLocation()
        else
            Library:Notify("Error: Location not found!", 3)
        end
    end
})


local gunTypes = {
    ["223Tan"] = Vector3.new(92973.07, 122097.95, 16997.25),
    ["Extended Mag"] = Vector3.new(93000, 122098, 17031),
    ["9mm Pistol"] = Vector3.new(92977, 122098, 17020),
    ["9mm Bullets"] = Vector3.new(93005.2, 122097.3, 17032.5),
    [".45 Infinity"] = Vector3.new(-169, 283.13, -579),
    [".45 InfinityExt"] = Vector3.new(92989.05, 122101.83, 16977.42),
}

function buyGunItem(targetPosition)
    local character = game.Players.LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local originalPosition = humanoidRootPart and humanoidRootPart.CFrame

    if not humanoidRootPart then
        Library:Notify("Error: HumanoidRootPart not found!", 3)
        return
    end

    local blackScreen = Instance.new("Frame")
    blackScreen.Size = UDim2.new(1, 0, 1, 0)
    blackScreen.BackgroundColor3 = Color3.new(0, 0, 0)
    blackScreen.BackgroundTransparency = 1
    blackScreen.Parent = game.Players.LocalPlayer.PlayerGui:WaitForChild("ScreenGui", 2) or Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)

    local hubLabel = Instance.new("TextLabel")
    hubLabel.Size = UDim2.new(0, 200, 0, 50)
    hubLabel.Position = UDim2.new(0.5, -100, 0.5, -25)
    hubLabel.BackgroundTransparency = 1
    hubLabel.TextColor3 = Color3.new(1, 1, 1)
    hubLabel.TextSize = 24
    hubLabel.Font = Enum.Font.GothamBold
    hubLabel.Text = "Proximity Hub"
    hubLabel.Parent = blackScreen

    function animateBlackScreen(fadeIn)
        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
        local goal = {BackgroundTransparency = fadeIn and 0 or 1}
        local tween = game:GetService("TweenService"):Create(blackScreen, tweenInfo, goal)
        tween:Play()
        tween.Completed:Wait()
    end

    getgenv().SwimMethod = true
    task.wait(1) 

    animateBlackScreen(true)

    humanoidRootPart.CFrame = CFrame.new(targetPosition)

    getgenv().SwimMethod = false
    
    task.wait(0.5)

    if keypress and keyrelease then
        keypress(0x45)
        task.wait(1.5)
        keyrelease(0x45)
    else
        fireproximityprompt = fireproximityprompt or function(obj)
            for _, v in ipairs(workspace:GetDescendants()) do
                if v:IsA("ProximityPrompt") and (v.Parent.Position - targetPosition).magnitude < 10 then
                    v:InputHoldBegin()
                    task.wait(1)
                    v:InputHoldEnd()
                    break
                end
            end
        end
        fireproximityprompt()
    end

    task.wait(1)

    if originalPosition then
        getgenv().SwimMethod = true
        task.wait(1) 
        humanoidRootPart.CFrame = originalPosition
        getgenv().SwimMethod = false
    end

    animateBlackScreen(false)
    blackScreen:Destroy()

    Library:Notify("Successfully Bought Item", 3)
end

Teleports:AddDropdown('GunShopDropdown', {
    Values = tableKeys(gunTypes),
    Default = "",
    Multi = false,
    Text = 'Select Gun',
    Callback = function(selected)
        if gunTypes[selected] then
            buyGunItem(gunTypes[selected])
        else
            Library:Notify("Error: Item not found!", 3)
        end
    end
})

local SelectedPlayer

local function updatePlayerList()
    local players = {}
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(players, player.Name)
        end
    end
    return players
end

local function findPlayer(playerName)
    SelectedPlayer = game.Players:FindFirstChild(playerName)
    if not SelectedPlayer then
        Library:Notify("Player not found!", 3)
    end
end
local playerDropdown = Teleports:AddDropdown('PlayerDropdown', {
    Values = updatePlayerList(), 
    Default = "",
    Multi = false,
    Text = 'Select Player',
    Callback = function(selectedPlayer)
        findPlayer(selectedPlayer) 
    end
})

game.Players.PlayerRemoving:Connect(function() 
    local newList = updatePlayerList()
    playerDropdown:SetValues(newList)
end)
Teleports:AddButton('GotoPlayer',  function()
        if not SelectedPlayer then
            Library:Notify("- No target selected to teleport to", 3)
            return
        end

        if not (SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChild("HumanoidRootPart")) then
            Library:Notify("- Unable to teleport: target's character not found", 3)
            return
        end

        local localPlayerCharacter = game.Players.LocalPlayer.Character
        if not (localPlayerCharacter and localPlayerCharacter:FindFirstChild("HumanoidRootPart")) then
            Library:Notify("- Unable to teleport: character not found", 3)
            return
        end

        local blackScreen = Instance.new("Frame")
        blackScreen.Size = UDim2.new(1, 0, 1, 0)
        blackScreen.BackgroundColor3 = Color3.new(0, 0, 0)
        blackScreen.BackgroundTransparency = 1
        blackScreen.Parent = game.Players.LocalPlayer.PlayerGui:WaitForChild("ScreenGui", 2) or Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)

        local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
        local fadeIn = {BackgroundTransparency = 0}
        local fadeInTween = game:GetService("TweenService"):Create(blackScreen, tweenInfo, fadeIn)
        fadeInTween:Play()
        fadeInTween.Completed:Wait()

        getgenv().SwimMethod = true
        task.wait(0.4)

        localPlayerCharacter.HumanoidRootPart.CFrame = SelectedPlayer.Character.HumanoidRootPart.CFrame

        getgenv().SwimMethod = false
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
        local fadeOut = {BackgroundTransparency = 1}
        local fadeOutTween = game:GetService("TweenService"):Create(blackScreen, tweenInfo, fadeOut)
        fadeOutTween:Play()

        Library:Notify("- Teleported to " .. SelectedPlayer.Name, 3)
    end
)
-- Vulnerabilitys
Vuln:AddButton("Infinite Money", function()
    local gui = Instance.new("ScreenGui", game.CoreGui)
    local player = game:GetService("Players").LocalPlayer
    
    if player.stored.FilthyStack.Value >= 900000 then
        Library:Notify("You're Close At Max Money!", 3)
        return
    end
    
    if player.stored.Money.Value < 2746 then
        Library:Notify("Not enough money! You need at least 3000$.", 3)
        return
    end

    gui.ResetOnSpawn = false
    gui.Name = "ProximityHubBlackscreen"
    gui.Parent = game:GetService("CoreGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BackgroundTransparency = 1
    frame.BorderSizePixel = 0
    frame.ZIndex = 999
    frame.Parent = gui

    local text2 = Instance.new("TextLabel")
    text2.Text = "discord.gg/proximityhub"
    text2.Size = UDim2.new(0.15, 0, 0.03, 0)
    text2.Position = UDim2.new(0.425, 0, 0.45, 0)
    text2.TextScaled = true
    text2.BackgroundTransparency = 1
    text2.TextColor3 = Color3.new(1, 1, 1)
    text2.Font = Enum.Font.SourceSansBold
    text2.TextStrokeTransparency = 0.7
    text2.TextStrokeColor3 = Color3.new(0.2, 0.2, 0.2)
    text2.ZIndex = 1000
    text2.Parent = frame

    local text3 = Instance.new("TextLabel")
    text3.Text = "üí∏ INFINITE MONEY üí∏"
    text3.Size = UDim2.new(0.2, 0, 0.04, 0)
    text3.Position = UDim2.new(0.4, 0, 0.5, 0)
    text3.TextScaled = true
    text3.BackgroundTransparency = 1
    text3.TextColor3 = Color3.new(1, 1, 1)
    text3.Font = Enum.Font.SourceSansBold
    text3.TextStrokeTransparency = 0.7
    text3.TextStrokeColor3 = Color3.new(0.2, 0.2, 0.2)
    text3.ZIndex = 1000
    text3.Parent = frame

    local countdownText = Instance.new("TextLabel")
    countdownText.Size = UDim2.new(0.25, 0, 0.04, 0)
    countdownText.Position = UDim2.new(0.375, 0, 0.55, 0)
    countdownText.TextScaled = true
    countdownText.BackgroundTransparency = 1
    countdownText.TextColor3 = Color3.new(1, 1, 1)
    countdownText.Font = Enum.Font.SourceSansBold
    countdownText.TextStrokeTransparency = 0.7
    countdownText.TextStrokeColor3 = Color3.new(0.2, 0.2, 0.2)
    countdownText.ZIndex = 1000
    countdownText.Parent = frame

    local errorText = Instance.new("TextLabel")
    errorText.Size = UDim2.new(0.35, 0, 0.04, 0)
    errorText.Position = UDim2.new(0.325, 0, 0.6, 0)
    errorText.TextScaled = true
    errorText.BackgroundTransparency = 1
    errorText.TextColor3 = Color3.new(1, 1, 1)
    errorText.Font = Enum.Font.SourceSansBold
    errorText.TextStrokeTransparency = 0.7
    errorText.TextStrokeColor3 = Color3.new(0.2, 0.2, 0.2)
    errorText.Text = ""
    errorText.ZIndex = 1000
    errorText.Parent = frame

    for i = 1, 20 do
        frame.BackgroundTransparency = 1 - (i / 20)
        task.wait(0.02)
    end
    
    local startTime = tick()
    local totalTime = 300
    local countdownActive = true
    
    function updateCountdown()
        while countdownActive do
            local elapsed = tick() - startTime
            local remaining = totalTime - elapsed
            
            if remaining <= 0 then
                countdownText.Text = "0.0"
                countdownActive = false
                break
            end
            
            local minutes = math.floor(remaining / 60)
            local seconds = math.floor(remaining % 60)
            local milliseconds = math.floor((remaining % 1) * 100)
            
            countdownText.Text = string.format("%02d:%02d.%02d", minutes, seconds, milliseconds)
            task.wait(0.01)
        end
        
        if not countdownActive then
            for i = 1, 20 do
                frame.BackgroundTransparency = i / 20
                task.wait(0.02)
            end
            if gui and gui.Parent then
                gui:Destroy()
            end
        end
    end
    
    task.spawn(updateCountdown)
    
    game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.PageUp then
            countdownActive = false
        end
    end)

    game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.PageDown then
            if gui and gui.Parent then
                gui:Destroy()
            end
        end
    end)
    local FruitZJobz = false
    local farmLoop = nil
    
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = game.Players.LocalPlayer
    local ExoticShopRemote = ReplicatedStorage:FindFirstChild("ExoticShopRemote")
    
    repeat task.wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not countdownActive then return end
    
    local ExoticStock = ReplicatedStorage:FindFirstChild("ExoticStock")
    if not ExoticShopRemote or not ExoticStock then 
        errorText.Text = "Failed to find required remotes"
        countdownActive = false
        return 
    end
    
    local items = {
        {name = "FreshWater", stock = ExoticStock.FreshWater},
        {name = "FijiWater", stock = ExoticStock.FijiWater},
        {name = "Ice-Fruit Bag", stock = ExoticStock["Ice-Fruit Bag"]},
        {name = "Ice-Fruit Cupz", stock = ExoticStock["Ice-Fruit Cupz"]}
    }
    for _, item in pairs(items) do
        if not item.stock or item.stock.Value < 1 then
            Library:Notify("Not enough stock for " .. item.name)
            countdownActive = false
            gui:Destroy()
            return
        end
    end
    
    if setsimulationradius then setsimulationradius(math.huge, math.huge) end
    pcall(function()
        sethiddenproperty(player, "MaximumSimulationRadius", math.huge)
        sethiddenproperty(player, "SimulationRadius", math.huge)
    end)
    
    function getCharacter()
        repeat task.wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        return player.Character, player.Character:FindFirstChild("HumanoidRootPart")
    end
    function teleport(position)
        getgenv().SwimMethod = true
        task.wait(1)
        local char, hrp = getCharacter()
        if not char or not hrp then return end
        char:PivotTo(CFrame.new(position))
        getgenv().SwimMethod = false
        Library:Notify("Teleported to location", 3)
    end
    
    function BuyItem(itemName)
        ExoticShopRemote:InvokeServer(itemName)
    end
    
    function nearprompt()
        local _, hrp = getCharacter()
        local closestPrompt, minDistance = nil, math.huge
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("ProximityPrompt") and v.Enabled and v.Parent and (v.Parent:IsA("BasePart") or v.Parent:IsA("Attachment")) then
                local part = v.Parent:IsA("Attachment") and v.Parent.Parent or v.Parent
                if part and part:IsA("BasePart") then
                    local distance = (hrp.Position - part.Position).Magnitude
                    if distance < minDistance then
                        closestPrompt, minDistance = v, distance
                    end
                end
            end
        end
        return closestPrompt
    end
    
    function setdelaysht(prompt)
        if prompt then prompt.HoldDuration = 0 end
    end

    function equipnclicc(itemName)
        local tool = player.Backpack:FindFirstChild(itemName) or player.Character:FindFirstChild(itemName)
        if tool then
            player.Character.Humanoid:EquipTool(tool)
            task.wait(0.2)
            local prompt = nearprompt()
            if prompt then
                setdelaysht(prompt)
                fireproximityprompt(prompt)
            end
        end
    end
    function RunOnce()
        teleport(Vector3.new(-433, 262, -683))
        task.wait(1)
    
        for _, item in pairs(items) do
            BuyItem(item.name)
            task.wait(0.5)
        end
        task.wait(1)
    
        local prompt = nearprompt()
        if prompt then
            setdelaysht(prompt)
            fireproximityprompt(prompt)
        end
    
        for _, item in pairs(items) do
            equipnclicc(item.name)
            task.wait(2)
        end
        Library:Notify("Successfully Put The Ingredients For KoolAid")
        local startTime = tick()
        farmLoop = task.spawn(function()
            while true do
                if tick() - startTime >= totalTime then
                    break
                end
                
                if tick() - startTime >= 290 then
                    Library:Notify("üí∏ Infinite Money Activated üí∏", 3)
                    loadstring(game:HttpGet("https://raw.githubusercontent.com/selciawashere/ProximityHub/refs/heads/main/Money",true))()
                    break
                end
                
                equipnclicc("Ice-Fruit Cupz")
                task.wait(0.5)
            end
        end)

        if totalTime == 290 then
            Library:Notify("üí∏ Infinite Money Activated üí∏", 3)
            loadstring(game:HttpGet("https://raw.githubusercontent.com/selciawashere/ProximityHub/refs/heads/main/Money",true))()
        end
        
        
    end
    RunOnce()
end)
Vuln:AddButton("Infinite Money (Manual) ", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/selciawashere/ProximityHub/refs/heads/main/Money",true))()
end)


Vuln:AddButton('Clean Money', function()
    local player = game:GetService("Players").LocalPlayer
    local originalPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.CFrame
    

    if player.stored.Money.Value >= 990000 then
        Library:Notify("You have max money already!", 3)
        return
    end
    
    function WaitForItem(itemName)
        local item = player.Backpack:FindFirstChild(itemName) or 
                     (player.Character and player.Character:FindFirstChild(itemName))
        return item
    end

    if player.stored.FilthyStack.Value < 100 then
        print("Not enough filthy stack, get some dirty money")
        return
    end

    for _, prompt in ipairs(workspace:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") and prompt.Parent.Name ~= "BagOfMoney" then
            prompt.HoldDuration = 0
        end
    end

    function TeleportToLocation(position)
        getgenv().SwimMethod = true
        task.wait(1)
        player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
        getgenv().SwimMethod = false
        Library:Notify("Teleported to location", 3)
    end
    
    local moneyReady = WaitForItem("MoneyReady")
    if not moneyReady then
        TeleportToLocation(Vector3.new(-788, 274, 1415))
        task.wait(0.1)
        
        repeat
            game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.1)
            game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.1)
        until WaitForItem("MoneyReady")
        if player.Character then
            task.spawn(function()
                for _, part in next, player.Character:GetDescendants() do
                    if part.Name ~= "HumanoidRootPart" and part:IsA("BasePart") and part.Anchored then
                        part.Anchored = false
                    end
                end
            end)
        end
    end

    local bagOfMoney = WaitForItem("BagOfMoney")
    if not bagOfMoney then
        TeleportToLocation(Vector3.new(-785, 272, 1420))
        task.wait(0.5)
     
        moneyReady = WaitForItem("MoneyReady")
        if moneyReady then
            player.Character.Humanoid:EquipTool(moneyReady)
        end
        
        repeat
            game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.1)
            game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.1)
        until WaitForItem("BagOfMoney")
        task.wait(2)
        if player.Character then
            task.spawn(function()
                for _, part in next, player.Character:GetDescendants() do
                    if part.Name ~= "HumanoidRootPart" and part:IsA("BasePart") and part.Anchored then
                        part.Anchored = false
                    end
                end
            end)
        end
    end

    TeleportToLocation(Vector3.new(-203, 284, -1202))
    task.wait(1)
    player.Character.HumanoidRootPart.Anchored = false
    
    bagOfMoney = WaitForItem("BagOfMoney")
    if bagOfMoney then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:EquipTool(bagOfMoney)
        end
    end
    
    local startTime = tick()
    local stopPressingE = false
    repeat
        if not stopPressingE then
            game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.1)
            game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.1)
        end
        
        if not WaitForItem("BagOfMoney") then
            stopPressingE = true
        end
        
        if tick() - startTime > 5 then
            break
        end
    until stopPressingE

    if originalPosition then
        TeleportToLocation(originalPosition.Position)
        player.Character.HumanoidRootPart.Anchored = false
    end
end)
Vuln:AddLabel("Dupe Is Currently Patched, Wait For Update.")
--[[
Vuln:AddButton({
    Text = 'Dupe Tools',
    Func = function()
        Library:Notify("Remember: There is a cooldown of 30 seconds", 3)
        
        -- Get required services
        local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
        local Players = cloneref(game:GetService('Players'))
        local Tool = tostring(Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"))
        
        if Tool == "nil" then
            return Library:Notify("[SleepyHub] - No Tool found", 5)
        end

        Players.LocalPlayer.Character:WaitForChild("Humanoid"):UnequipTools()

        -- Disable market GUI
        local DisableMarketGui = Players.LocalPlayer.PlayerGui.ChildAdded:Connect(function(Child)
            task.wait()
            Child:Destroy()
        end)

        -- Execute both methods simultaneously
        task.spawn(function()
            -- Default method
            if getcar() then
                BypassTp(getcar().Body:FindFirstChild("TrunckStorage").CFrame)
                
                task.spawn(function()
                    game.ReplicatedStorage.BackpackRemote:InvokeServer("Store", Tool)
                end)
                
                task.spawn(function()
                    game.ReplicatedStorage.ListWeaponRemote:FireServer(Tool, 50000)
                    game:GetService("ReplicatedStorage").TrunkStorage:FireServer("Store", Tool)
                end)
                
                task.wait(2)
                
                task.spawn(function()
                    game.ReplicatedStorage.BuyItemRemote:FireServer(Tool, "Remove")
                end)
                
                task.spawn(function()
                    game:GetService("ReplicatedStorage").TrunkStorage:FireServer("Grab", Tool)
                end)
                
                task.spawn(function()
                    game.ReplicatedStorage.BackpackRemote:InvokeServer("Grab", Tool)
                end)
            end
        end)

        task.spawn(function()
            -- Safe method
            local Safe = workspace["1# Map"]["2 Crosswalks"].Safes:GetChildren()[5]
            local OldCFrame = Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
            
            BypassTp(Safe)
            wait(0.5)
            
            task.spawn(function()
                ReplicatedStorage.BackpackRemote:InvokeServer("Store", Tool)
            end)
            
            task.spawn(function()
                ReplicatedStorage.Inventory:FireServer("Change", Tool, "Backpack", Safe)
            end)
            
            wait(0.5)
            BypassTp(OldCFrame)
            wait(1.2)
            
            ReplicatedStorage.BackpackRemote:InvokeServer("Grab", Tool)
            
            if not Toggles.StoreDupe.Value then
                ReplicatedStorage.Inventory:FireServer("Change", Tool, "Inv", Safe)
            end
            
            wait(0.5)
            BypassTp(OldCFrame)
        end)

        task.wait(1)
        DisableMarketGui:Disconnect()
    end,
    DoubleClick = false,
    Tooltip = nil
})
]]
-- QuickShop
QuickShop:AddButton('Buy Shiesty', function()
    local ohString1 = "Shiesty"
    game:GetService("ReplicatedStorage").ShopRemote:InvokeServer(ohString1)
end)

QuickShop:AddButton('Buy BluGloves', function()
    local ohString1 = "BluGloves"
    game:GetService("ReplicatedStorage").ShopRemote:InvokeServer(ohString1)
end)

QuickShop:AddButton('Buy WhiteGloves', function()
    local ohString1 = "WhiteGloves"
    game:GetService("ReplicatedStorage").ShopRemote:InvokeServer(ohString1)
end)

QuickShop:AddButton('Buy BlackGloves', function()
    local ohString1 = "BlackGloves"
    game:GetService("ReplicatedStorage").ShopRemote:InvokeServer(ohString1)
end)


QuickShop:AddLabel('+++++ Exotic Dealer +++++') 

QuickShop:AddButton('Buy Fake Card', function()
    local args = {
        [1] = "FakeCard"
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("ExoticShopRemote"):InvokeServer(unpack(args))
end)


QuickShop:AddButton('Buy IceFruit Bag', function()
    local args = {
        [1] = "Ice-Fruit Bag"
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("ExoticShopRemote"):InvokeServer(unpack(args))
    
    
    
end)

QuickShop:AddButton('Buy IceFruit Cupz', function()
    local args = {
        [1] = "Ice-Fruit Cupz"
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("ExoticShopRemote"):InvokeServer(unpack(args))
    
    
end)

QuickShop:AddButton('Buy Fiji Water', function()
    local args = {
        [1] = "FijiWater"
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("ExoticShopRemote"):InvokeServer(unpack(args))
    
    
end)
QuickShop:AddButton('Buy Fresh Water', function()
    local args = {
        [1] = "FreshWater"
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("ExoticShopRemote"):InvokeServer(unpack(args))
end)

QuickShop:AddButton('Buy AppleJuice', function()
    local ohString1 = "AppleJuice"

    game:GetService("ReplicatedStorage").ShopRemote:InvokeServer(ohString1)
end)

QuickShop:AddButton('Buy GreenAppleJuice', function()
    local ohString1 = "GreenAppleJuice"

    game:GetService("ReplicatedStorage").ShopRemote:InvokeServer(ohString1)
end)
task.spawn(function()
    while task.wait() do
        if getgenv().SwimMethod then
            local player = game:GetService("Players").LocalPlayer
            if player and player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.FallingDown)
            end
        end
    end
end)
-- Autofarmss
AutofarmS:AddToggle('StudioAutofarm', {
    Text = 'Studio Autofarm',
    Default = false, 
    Callback = function(State)
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        
        getgenv().StudioAutofarmEnabled = State
        
        local function updateCharacterReferences()
            local playerCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            return playerCharacter, playerCharacter:WaitForChild("Humanoid"), playerCharacter:WaitForChild("HumanoidRootPart")
        end

        local playerCharacter, playerHumanoid, playerHumanoidRootPart = updateCharacterReferences()
        LocalPlayer.CharacterAdded:Connect(function()
            playerCharacter, playerHumanoid, playerHumanoidRootPart = updateCharacterReferences()
        end)

        local originalPosition = playerCharacter and playerCharacter:GetPrimaryPartCFrame()

        local function robStudio(studioPay)
            if not getgenv().StudioAutofarmEnabled then return end
            
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            if not character then return end

            local studioPath = workspace.StudioPay.Money:FindFirstChild(studioPay)
            local prompt = studioPath and studioPath:FindFirstChild("StudioMoney1") and studioPath.StudioMoney1:FindFirstChild("Prompt")
            
            if prompt then
                getgenv().SwimMethod = true
                task.wait(0.5)

                local targetPosition = prompt.Parent.Position + Vector3.new(0, 2, 0)
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.CFrame = CFrame.new(targetPosition)
                end
                
                getgenv().SwimMethod = false
                task.wait(0.2)
                
                prompt.HoldDuration = 0
                prompt.RequiresLineOfSight = false
                
                for i = 1, 3 do
                    pcall(function()
                        fireproximityprompt(prompt)
                    end)
                    task.wait(0.1)
                end
            end
        end

        if State then
            task.spawn(function()
                while getgenv().StudioAutofarmEnabled do
                    for _, pay in ipairs({"StudioPay1", "StudioPay2", "StudioPay3"}) do
                        if not getgenv().StudioAutofarmEnabled then break end
                        robStudio(pay)
                        task.wait(0.5)
                    end
                    
                    local character = LocalPlayer.Character
                    if character then
                        local humanoid = character:FindFirstChild("Humanoid")
                        if humanoid then
                            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                        end
                    end
                    
                    task.wait(0.5)
                end
            end)
        else
            getgenv().StudioAutofarmEnabled = false
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
                if originalPosition then
                    getgenv().SwimMethod = true
                    task.wait(0.5)
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = originalPosition
                    end
                    getgenv().SwimMethod = false
                end
            end
        end
    end
})

-- Playerrs
Playerr:AddSlider("FlySpeedSlider", {
    Text = "Fly Speed",
    Min = 1,
    Max = 500,
    Default = 50,
    Rounding = 1,
    Callback = function(value)
        flySpeed = value
    end
})

Playerr:AddToggle("FlyNewMethod", {
    Text = "Fly",
    Default = false,
    Callback = function(state)
        FLYING = state
        if state then
            getgenv().SwimMethod = true
            task.wait(0.3)
            local LocalPlayer = Players.LocalPlayer
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            if not character then return end
            
            local humanoid = character:FindFirstChild("Humanoid")
            if not humanoid then return end
            
            humanoid.PlatformStand = true
            local Head = character:WaitForChild("Head")
            Head.Anchored = true
            
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.LocalTransparencyModifier = 0
                end
            end
            
            if CFloop then CFloop:Disconnect() end
            CFloop = RunService.Heartbeat:Connect(function(deltaTime)
                local moveDirection = humanoid.MoveDirection * (flySpeed * deltaTime)
                local headCFrame = Head.CFrame
                local cameraCFrame = workspace.CurrentCamera.CFrame
                local cameraOffset = headCFrame:ToObjectSpace(cameraCFrame).Position
                cameraCFrame = cameraCFrame * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
                local cameraPosition = cameraCFrame.Position
                local headPosition = headCFrame.Position

                local objectSpaceVelocity = CFrame.new(cameraPosition, Vector3.new(headPosition.X, cameraPosition.Y, headPosition.Z)):VectorToObjectSpace(moveDirection)
                Head.CFrame = CFrame.new(headPosition) * (cameraCFrame - cameraPosition) * CFrame.new(objectSpaceVelocity)
            end)
        else
            if CFloop then
                CFloop:Disconnect()
                local LocalPlayer = Players.LocalPlayer
                local character = LocalPlayer.Character
                local humanoid = character and character:FindFirstChildOfClass('Humanoid')
                if humanoid then
                    humanoid.PlatformStand = false
                end
                local Head = character and character:WaitForChild("Head")
                if Head then
                    Head.Anchored = false
                end
                
                getgenv().SwimMethod = false
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                end
            end
        end
    end
}):AddKeyPicker('FlyNewMethod', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Fly',
    NoUI = false
})
Playerr:AddToggle("NoclipToggle", {
    Text = "Noclip",
    Default = false,
    Tooltip = "Toggle Noclip",
    Callback = function(Value)
        getgenv().NoclipEnabled = Value
        
        if Value then
            local character = game.Players.LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
            
            game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
                if getgenv().NoclipEnabled then
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            local character = game.Players.LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
}):AddKeyPicker('Noclip', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Noclip',
    NoUI = false
})



local infJump
local infJumpDebounce = false
local noCooldownJump = false

Playerr:AddToggle('InfiniteJumpToggle', {
    Text = 'Infinite Jump',
    Default = false,
    Callback = function(Value)
        getgenv().InfiniteJumpEnabled = Value
        
        if infJump then
            infJump:Disconnect()
        end
        infJumpDebounce = false

        if Value then
            infJump = UserInputService.JumpRequest:Connect(function()
                if not getgenv().InfiniteJumpEnabled then return end
                
                local character = game.Players.LocalPlayer.Character
                local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
                
                if not infJumpDebounce or noCooldownJump then
                    if not noCooldownJump then
                        infJumpDebounce = true
                    end
                    
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                    
                    if not noCooldownJump then
                        task.wait(0.1)
                        infJumpDebounce = false
                    end
                end
            end)

            game.Players.LocalPlayer.CharacterAdded:Connect(function()
                if getgenv().InfiniteJumpEnabled then
                    infJumpDebounce = false
                end
            end)
        end
    end
}):AddKeyPicker('InfiniteJumpKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Toggle Infinite Jump',
    NoUI = false
})

-- Extraboxs
local LocalPlayer = game:GetService("Players").LocalPlayer

ExtraBox:AddToggle('InfiniteSleep', {
    Text = 'Infinite Sleep',
    Default = false,
    Callback = function(Value)
        local sleepBar = LocalPlayer.PlayerGui.SleepGui.Frame.sleep.SleepBar:FindFirstChild("sleepScript")
        if sleepBar then
            sleepBar.Enabled = not Value
        end
    end
})
ExtraBox:AddToggle('InfiniteStamina', {
    Text = 'Infinite Stamina', 
    Default = false,
    Callback = function(Value)
        local StaminaBar = LocalPlayer.PlayerGui:FindFirstChild("Run") and 
            LocalPlayer.PlayerGui.Run.Frame.Frame.Frame:FindFirstChild("StaminaBarScript")
        if StaminaBar then
            StaminaBar.Enabled = not Value
        end
    end
})

ExtraBox:AddToggle('InfiniteHunger', {
    Text = 'Infinite Hunger',
    Default = false,
    Callback = function(Value)
        local hungerBar = LocalPlayer.PlayerGui.Hunger.Frame.Frame.Frame:FindFirstChild("HungerBarScript")
        if hungerBar then
            hungerBar.Enabled = not Value
        end
    end
})



ExtraBox:AddToggle('AntiJumpCooldown', {
    Text = 'Anti Jump Cooldown',
    Default = false,
    Callback = function(Value)
        local jumpDebounce = LocalPlayer.PlayerGui:FindFirstChild("JumpDebounce")
        local localScript = jumpDebounce and jumpDebounce:FindFirstChild("LocalScript")
        if localScript then
            localScript.Enabled = not Value
        end
    end
})

local antiFallConn
ExtraBox:AddToggle('AntiFallDamage', {
    Text = 'Anti Fall Damage',
    Default = false,
    Callback = function(Value)
        if not Value then
            if antiFallConn then
                antiFallConn:Disconnect()
                antiFallConn = nil
            end
            return
        end

        function handleCharacter(char)
            if antiFallConn then
                antiFallConn:Disconnect()
            end

            antiFallConn = RunService.Heartbeat:Connect(function()
                local fallDamage = char:FindFirstChild("FallDamageRagdoll")
                if fallDamage then
                    fallDamage:Destroy()
                end
            end)
        end

        handleCharacter(LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait())
        LocalPlayer.CharacterAdded:Connect(handleCharacter)
    end
})
ExtraBox:AddToggle('InstantInteraction', {
    Text = 'Instant Interaction', 
    Default = false,
    Callback = function(Value)
        local Workspace = game:GetService("Workspace")
        
        for _, v in ipairs(Workspace:GetDescendants()) do
            if v.ClassName == "ProximityPrompt" then
                v.HoldDuration = Value and 0 or v.HoldDuration
            end
        end

        local connection
        if Value then
            connection = Workspace.DescendantAdded:Connect(function(descendant)
                if descendant.ClassName == "ProximityPrompt" then
                    descendant.HoldDuration = 0
                end
            end)
        else
            if connection then
                connection:Disconnect()
            end
        end
    end
})

function onCharacterDied()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        lastDeathPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    end
end

function connectDeathHandler(char)
    local humanoid = char:WaitForChild("Humanoid")
    if deathConnection then
        deathConnection:Disconnect()
    end
    deathConnection = humanoid.HealthChanged:Connect(function(health)
        if health <= 0 then
            onCharacterDied()
        end
    end)
end

if LocalPlayer.Character then
    connectDeathHandler(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(connectDeathHandler)

ExtraBox:AddToggle('InstantRespawn', {
    Text = 'Instant Respawn',
    Default = false,
    Callback = function(Value)
        getgenv().InstantRespawnEnabled = Value
        
        if Value then
            task.spawn(function()
                while getgenv().InstantRespawnEnabled do
                    local character = LocalPlayer.Character
                    if character and character:FindFirstChild("Humanoid") then
                        if character.Humanoid.Health <= 0 then
                            task.wait(0.1)  
                            game:GetService("ReplicatedStorage").RespawnRE:FireServer()
                        end
                    end
                    task.wait(0.1) 
                end
            end)
        end
    end
})

ExtraBox:AddToggle('RespawnPosition', {
    Text = 'Respawn Where You Died',
    Default = false,
    Callback = function(Value)
        autoTPEnabled = Value
        
        if charAddedConn then
            charAddedConn:Disconnect()
            charAddedConn = nil
        end

        if Value then
            charAddedConn = LocalPlayer.CharacterAdded:Connect(function(char)
                if autoTPEnabled and lastDeathPosition then
                    local hrp = char:WaitForChild("HumanoidRootPart")
                    task.wait(0.1)
                    hrp.CFrame = lastDeathPosition
                end
            end)
        end
    end
})

ExtraBox:AddToggle('NoRentPay', {
    Text = 'No Rent Pay',
    Default = false,
    Callback = function(Value)
        local rentScript = game:GetService("StarterGui").RentGui:FindFirstChild("LocalScript")
        if rentScript then
            rentScript.Enabled = not Value
        end
    end
})
-- Animationss
local LocalPlayer = game:GetService("Players").LocalPlayer

Animations:AddToggle('CrawlAnimation', {
    Text = 'Crawl Animation',
    Default = false,
    Callback = function(Value)
        if Value then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character:FindFirstChild("crawlWhenDamaged") and LocalPlayer.Character.crawlWhenDamaged:FindFirstChild("crawlAnimation") then
                local anim = LocalPlayer.Character.Humanoid:LoadAnimation(LocalPlayer.Character.crawlWhenDamaged.crawlAnimation)
                if anim then
                    anim:Play()
                end
            end
        else
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                for _, anim in pairs(LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
                    if anim.Animation and anim.Animation.AnimationId == LocalPlayer.Character.crawlWhenDamaged.crawlAnimation.AnimationId then
                        anim:Stop()
                    end
                end
            end
        end
    end
}):AddKeyPicker('CrawlKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Toggle Crawl Animation',
    NoUI = false
})

Animations:AddToggle('CuffedAnimation', {
    Text = 'Cuff Animation', 
    Default = false,
    Callback = function(Value)
        if Value then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and game:GetService("ReplicatedStorage"):FindFirstChild("cuffed") then
                local anim = LocalPlayer.Character.Humanoid:LoadAnimation(game:GetService("ReplicatedStorage").cuffed)
                if anim then
                    anim:Play()
                end
            end
        else
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                for _, anim in pairs(LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
                    if anim.Animation and anim.Animation.AnimationId == game:GetService("ReplicatedStorage").cuffed.AnimationId then
                        anim:Stop()
                    end
                end
            end
        end
    end
}):AddKeyPicker('CuffedKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle', 
    Text = 'Toggle Cuffed Animation',
    NoUI = false
})

Animations:AddToggle('LowHealthAnimation', {
    Text = 'Low Health Animation',
    Default = false, 
    Callback = function(Value)
        if Value then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and game:GetService("ReplicatedStorage"):FindFirstChild("LowHealthAnim") then
                local anim = LocalPlayer.Character.Humanoid:LoadAnimation(game:GetService("ReplicatedStorage").LowHealthAnim)
                if anim then
                    anim:Play()
                end
            end
        else
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                for _, anim in pairs(LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
                    if anim.Animation and anim.Animation.AnimationId == game:GetService("ReplicatedStorage").LowHealthAnim.AnimationId then
                        anim:Stop()
                    end
                end
            end
        end
    end
}):AddKeyPicker('LowHealthKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Toggle Low Health Animation',
    NoUI = false
})

Animations:AddToggle('CarriedAnimation', {
    Text = 'Carry Animation',
    Default = false,
    Callback = function(Value)
        if Value then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and game:GetService("ReplicatedStorage"):FindFirstChild("BeingCarried") then
                local anim = LocalPlayer.Character.Humanoid:LoadAnimation(game:GetService("ReplicatedStorage").BeingCarried)
                if anim then
                    anim:Play()
                end
            end
        else
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                for _, anim in pairs(LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
                    if anim.Animation and anim.Animation.AnimationId == game:GetService("ReplicatedStorage").BeingCarried.AnimationId then
                        anim:Stop()
                    end
                end
            end
        end
    end
}):AddKeyPicker('CarriedKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Toggle Carried Animation',
    NoUI = false
})


local lplr = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local worldToViewportPoint = camera.WorldToViewportPoint

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

local ESP = {
    enabled = false,
    teamcheck = false,
    outlines = false,
    box_filled = false,
    box_outline = false,
    tracer_outline = false,
    team_boxes = {false, Color3.fromRGB(255, 255, 255), 3, 1},
    team_health = false,
    health_transparency = 1,
    team_names = {false, Color3.fromRGB(255, 255, 255), 1},
    team_distance = false,
    distance_transparency = 1,
    team_tracer = {false, Color3.fromRGB(255, 255, 255), 2, 1}
}

local playerDrawings = {}

function createBoxEsp(v)
    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Filled = false

    local HealthBar = Drawing.new("Line")
    HealthBar.Visible = false
    HealthBar.Thickness = 2

    local NameTag = Drawing.new("Text")
    NameTag.Visible = false
    NameTag.Size = 9
    NameTag.Center = true

    local DistanceTag = Drawing.new("Text")
    DistanceTag.Visible = false
    DistanceTag.Size = 9
    DistanceTag.Center = true

    local Tracer = Drawing.new("Line")
    Tracer.Visible = false

    local TracerOutline = Drawing.new("Line")
    TracerOutline.Visible = false
    TracerOutline.Color = Color3.new(0, 0, 0)

    playerDrawings[v] = {
        Box = Box,
        Health = HealthBar,
        Name = NameTag,
        Distance = DistanceTag,
        Tracer = Tracer,
        TracerOutline = TracerOutline
    }

    game:GetService("RunService").RenderStepped:Connect(function()
        if not ESP.enabled then
            for _, d in pairs(playerDrawings[v]) do
                d.Visible = false
            end
            return
        end

        if v and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("Head") and v ~= lplr and v.Character.Humanoid.Health > 0 then
            if ESP.teamcheck and v.Team == lplr.Team then
                for _, d in pairs(playerDrawings[v]) do
                    d.Visible = false
                end
                return
            end

            local Root = v.Character.HumanoidRootPart
            local Head = v.Character.Head
            local RootPos, onScreen = camera:WorldToViewportPoint(Root.Position)
            local HeadPos = camera:WorldToViewportPoint(Head.Position + HeadOff)
            local LegPos = camera:WorldToViewportPoint(Root.Position - LegOff)

            local boxSize = Vector2.new(1000 / RootPos.Z, HeadPos.Y - LegPos.Y)
            local boxPos = Vector2.new(RootPos.X - boxSize.X / 2, RootPos.Y - boxSize.Y / 2)

            Box.Position = boxPos
            Box.Size = boxSize
            Box.Filled = ESP.box_filled
            Box.Color = ESP.team_boxes[2]
            Box.Thickness = ESP.box_outline and ESP.team_boxes[3] or 0
            Box.Transparency = ESP.team_boxes[4]
            Box.Visible = ESP.team_boxes[1] and onScreen

            if ESP.team_health then
                local hp = v.Character.Humanoid.Health / v.Character.Humanoid.MaxHealth
                HealthBar.From = Vector2.new(boxPos.X + boxSize.X + 5, boxPos.Y + boxSize.Y * (1 - hp))
                HealthBar.To = Vector2.new(boxPos.X + boxSize.X + 5, boxPos.Y + boxSize.Y)
                HealthBar.Color = Color3.new(1 - hp, hp, 0)
                HealthBar.Transparency = ESP.health_transparency
                HealthBar.Visible = onScreen
            else
                HealthBar.Visible = false
            end

            NameTag.Text = v.Name
            NameTag.Position = Vector2.new(boxPos.X + boxSize.X / 2, boxPos.Y - 15)
            NameTag.Color = ESP.team_names[2]
            NameTag.Outline = ESP.outlines
            NameTag.OutlineColor = Color3.new(0, 0, 0)
            NameTag.Transparency = ESP.team_names[3]
            NameTag.Visible = ESP.team_names[1] and onScreen

            local dist = (lplr.Character.HumanoidRootPart.Position - Root.Position).Magnitude
            DistanceTag.Text = string.format("%dm", math.floor(dist))
            DistanceTag.Position = Vector2.new(boxPos.X + boxSize.X / 2, boxPos.Y + boxSize.Y + 1)
            DistanceTag.Color = Color3.fromRGB(255, 255, 255)
            DistanceTag.Outline = ESP.outlines
            DistanceTag.OutlineColor = Color3.new(0, 0, 0)
            DistanceTag.Transparency = ESP.distance_transparency
            DistanceTag.Visible = ESP.team_distance and onScreen

            local from = camera:WorldToViewportPoint(lplr.Character.Head.Position)
            Tracer.From = Vector2.new(from.X, from.Y)
            Tracer.To = Vector2.new(RootPos.X, RootPos.Y)
            Tracer.Color = ESP.team_tracer[2]
            Tracer.Thickness = ESP.team_tracer[3]
            Tracer.Transparency = ESP.team_tracer[4]
            Tracer.Visible = ESP.team_tracer[1] and onScreen

            TracerOutline.From = Tracer.From
            TracerOutline.To = Tracer.To
            TracerOutline.Thickness = ESP.team_tracer[3] + 2
            TracerOutline.Visible = ESP.team_tracer[1] and ESP.tracer_outline and onScreen
        else
            for _, d in pairs(playerDrawings[v]) do
                d.Visible = false
            end
        end
    end)
end

for _, v in ipairs(game.Players:GetPlayers()) do
    if v ~= lplr then
        createBoxEsp(v)
    end
end

game.Players.PlayerAdded:Connect(function(v)
    if v ~= lplr then
        createBoxEsp(v)
    end
end)
-- ESPSettingss
ESPSettings:AddToggle('EnableESP', {
    Text = 'Enable ESP',
    Default = false,
    Callback = function(Value)
        ESP.enabled = Value
    end
})

ESPSettings:AddToggle('TeamCheck', {
    Text = 'Team Check',
    Default = false,
    Callback = function(Value)
        ESP.teamcheck = Value
    end
})

ESPSettings:AddToggle('GlobalOutlineToggle', {
    Text = 'Global ESP Outlines',
    Default = true,
    Callback = function(Value)
        ESP.outlines = Value
    end
})

ESPBoxes:AddToggle('BoxESP', {
    Text = 'Box ESP',
    Default = false,
    Callback = function(Value)
        ESP.team_boxes[1] = Value
    end
}):AddColorPicker('BoxColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Box Color',
    Callback = function(Value)
        ESP.team_boxes[2] = Value
    end
})

ESPBoxes:AddToggle('FilledBox', {
    Text = 'Filled Box',
    Default = false,
    Callback = function(Value)
        ESP.box_filled = Value
    end
})

ESPBoxes:AddToggle('BoxOutline', {
    Text = 'Box Outline',
    Default = false,
    Callback = function(Value)
        ESP.box_outline = Value
    end
})

ESPBoxes:AddSlider('BoxTransparencySlider', {
    Text = 'Box Transparency',
    Default = 1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESP.team_boxes[4] = Value
    end
})

ESPTracers:AddToggle('TracerESP', {
    Text = 'Tracer ESP',
    Default = false,
    Callback = function(Value)
        ESP.team_tracer[1] = Value
    end
}):AddColorPicker('TracerColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Tracer Color',
    Callback = function(Value)
        ESP.team_tracer[2] = Value
    end
})

ESPTracers:AddToggle('TracerOutline', {
    Text = 'Tracer Outline',
    Default = false,
    Callback = function(Value)
        ESP.tracer_outline = Value
    end
})

ESPTracers:AddSlider('TracerThicknessSlider', {
    Text = 'Tracer Thickness',
    Default = 2,
    Min = 1,
    Max = 5,
    Rounding = 1,
    Callback = function(Value)
        ESP.team_tracer[3] = Value
    end
})

ESPTracers:AddSlider('TracerTransparencySlider', {
    Text = 'Tracer Transparency',
    Default = 1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESP.team_tracer[4] = Value
    end
})

ESPNames:AddToggle('NameESP', {
    Text = 'Name ESP',
    Default = false,
    Callback = function(Value)
        ESP.team_names[1] = Value
    end
}):AddColorPicker('NameColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Name Color',
    Callback = function(Value)
        ESP.team_names[2] = Value
    end
})

ESPNames:AddSlider('NameTransparencySlider', {
    Text = 'Name Transparency',
    Default = 1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESP.team_names[3] = Value
    end
})

ESPHealthBars:AddToggle('HealthESP', {
    Text = 'Health ESP',
    Default = false,
    Callback = function(Value)
        ESP.team_health = Value
    end
})

ESPHealthBars:AddSlider('HealthTransparencySlider', {
    Text = 'Health Bar Transparency',
    Default = 1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESP.health_transparency = Value
    end
})

ESPDistance:AddToggle('DistanceESP', {
    Text = 'Distance ESP',
    Default = false,
    Callback = function(Value)
        ESP.team_distance = Value
    end
})

ESPDistance:AddSlider('DistanceTransparencySlider', {
    Text = 'Distance Transparency',
    Default = 1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ESP.distance_transparency = Value
    end
})




function FB(enabled)
    local Lighting = game:GetService("Lighting")
    if enabled then
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    else
        Lighting.Brightness = 1
        Lighting.ClockTime = 12
        Lighting.FogEnd = 1000
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(100, 100, 100)
    end
end
-- VisualsTabs
VisualsTab:AddToggle('FullbrightToggle', {
    Text = 'Fullbright',
    Default = false,
    Tooltip = nil,
    Callback = function(Value)
        FB(Value)
    end
})



local FOVring = Drawing.new("Circle")
FOVring.Thickness = 2
FOVring.Radius = fovRadius
FOVring.NumSides = 90
FOVring.Filled = false
FOVring.Transparency = 0.9
FOVring.Color = Color3.fromRGB(255, 128, 128)
FOVring.Visible = false

function hsvToRgb(h)
    return Color3.fromHSV(h % 1, 1, 1)
end

function highlightTarget(target)
    if not highlightEnabled then return end
    if target and target.Character then
        local hl = target.Character:FindFirstChild("AimbotHighlight")
        if not hl then
            hl = Instance.new("Highlight", target.Character)
            hl.Name = "AimbotHighlight"
            hl.FillColor = Color3.fromRGB(255, 0, 0)
            hl.OutlineColor = Color3.fromRGB(255, 255, 255)
            hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        end
    end
end

function clearHighlights()
    for _, plr in pairs(Players:GetPlayers()) do
        if plr.Character then
            local hl = plr.Character:FindFirstChild("AimbotHighlight")
            if hl then hl:Destroy() end
        end
    end
end

function getClosest(mousePos)
    local target, shortest = nil, math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild(lockPart) then
            if (not teamCheck or player.Team ~= Players.LocalPlayer.Team) then
                if (not checkIfAlive or (player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0)) then
                    local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(player.Character[lockPart].Position)
                    if onScreen then
                        local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                        if distance < shortest and distance <= fovRadius then
                            shortest = distance
                            target = player
                        end
                    end
                end
            end
        end
    end

    return target
end

function predictPosition(target)
    if target and target.Character and target.Character:FindFirstChild(lockPart) then
        local velocity = target.Character[lockPart].Velocity
        local position = target.Character[lockPart].Position
        return position + (velocity * predictionFactor)
    end
end

local isAimbotKeyDown = false

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode.Name == _G.AimbotKeyName then
        isAimbotKeyDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode.Name == _G.AimbotKeyName then
        isAimbotKeyDown = false
    end
end)


local hue = 0
RunService.RenderStepped:Connect(function()
    local cam = workspace.CurrentCamera
    local mousePos = UserInputService:GetMouseLocation()
    FOVring.Position = Vector2.new(mousePos.X, mousePos.Y)
    if _G.RainbowFOV then
        hue = (hue + 0.01) % 1
        FOVring.Color = hsvToRgb(hue)
    end

    if _G.AimbotPowerEnabled and isAimbotKeyDown then
        local target = getClosest(Vector2.new(mousePos.X, mousePos.Y))
        highlightTarget(target)

        if target and target.Character and target.Character:FindFirstChild(lockPart) then
            local predicted = predictPosition(target)
            if predicted then
                cam.CFrame = cam.CFrame:Lerp(CFrame.new(cam.CFrame.Position, predicted), smoothing)
            end
        end
    else
        clearHighlights()
    end
end)
-- Aimbots
Aimbot:AddToggle('EnableAimbot', {
    Text = 'Enable Aimbot',
    Default = false,
    Callback = function(val)
        _G.AimbotPowerEnabled = val
    end
}):AddKeyPicker('Aimbot', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Toggle Aimbot',
    NoUI = false
})

Aimbot:AddInput('AimbotKeyInput', {
    Default = _G.AimbotKeyName,
    Text = 'Hold Key Activation (E/F)',
    Placeholder = 'Enter key (case-sensitive)',
    Callback = function(val)
        _G.AimbotKeyName = val:upper()
    end
})

Aimbot:AddToggle('TeamCheckToggle', {
    Text = 'Team Check',
    Default = false,
    Callback = function(val)
        teamCheck = val
    end
})

Aimbot:AddToggle('HighlightTargetToggle', {
    Text = 'Highlight Target',
    Default = false,
    Callback = function(val)
        highlightEnabled = val
        if not val then clearHighlights() end
    end
})

Aimbot:AddToggle('AliveCheckToggle', {
    Text = 'Check if Player is Alive',
    Default = true,
    Callback = function(val)
        checkIfAlive = val
    end
})

Aimbot:AddDivider()
Aimbot:AddLabel("Fov Settings")

Aimbot:AddSlider('FOVSlider', {
    Text = 'FOV Radius',
    Min = 10,
    Max = 300,
    Rounding = 1,
    Default = fovRadius,
    Callback = function(val)
        fovRadius = val
        FOVring.Radius = val
    end
})
Aimbot:AddToggle('FOVVisible', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(val)
        _G.FOVCircleVisible = val
        FOVring.Visible = val
    end
}):AddKeyPicker('CrawlKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Toggle Crawl Animation',
    NoUI = false
})



Aimbot:AddToggle('RainbowFOVToggle', {
    Text = 'Rainbow FOV',
    Default = false,
    Callback = function(val)
        _G.RainbowFOV = val
    end
})

function dmg(target, hpart, damage)
    game:GetService("ReplicatedStorage").InflictTarget:FireServer(
        game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool"),
        game:GetService("Players").LocalPlayer,
        target.Character.Humanoid,
        target.Character[hpart],
        damage,
        {0, 0, false, false,
            game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool").GunScript_Server.IgniteScript,
            game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool").GunScript_Server.IcifyScript,
            100, 100},
        {false, 5, 3},
        target.Character[hpart],
        {false, {1930359546}, 1, 1.5, 1},
        nil,
        nil,
        true)
end


function Check(head)
    if head.Parent == localplayer.Character or not _G.wallCheck then
        return false
    end

    local castPoints = {localplayer.Character.Head.Position, head.Position}
    local ignoreList = {localplayer.Character, head.Parent}
    local obstructingParts = camera:GetPartsObscuringTarget(castPoints, ignoreList)


    return #obstructingParts > 0
end

function getNearestPlayerToLocalPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= localplayer and player.Character and player.Character:FindFirstChild("Humanoid") and
            player.Character.Humanoid.Health > 0 and
            player.Character:FindFirstChild("LowerTorso") and
            player.Character:FindFirstChild("Head") then

            local head = player.Character.Head
            if not _G.aimbot then return end
            if not Check(head) then
                local localPlayerCharacter = localplayer.Character
                if localPlayerCharacter then
                    local localPlayerPosition = localPlayerCharacter.PrimaryPart.Position
                    local playerPosition = player.Character.PrimaryPart.Position

                    local distance = (localPlayerPosition - playerPosition).magnitude

                    if distance < shortestDistance then
                        closestPlayer = player
                        shortestDistance = distance
                    end
                end
            end
        end
    end

    return closestPlayer
end
GetSeat = function()
    for i,v in pairs(workspace:GetDescendants()) do 
       if v:IsA("Seat") and not v.Parent:FindFirstChild("DriverSeat") then 
        return v
       end 
    end 
end 
getgenv().saim = false

function getcp()
local mouse = game.Players.LocalPlayer:GetMouse()
local hit = mouse.Hit.Position
local maxdis = math.huge
local target = nil
for i, v in next, game.Players:GetChildren() do
if v.Character and v ~= game.Players.LocalPlayer and v.Character:FindFirstChild("HumanoidRootPart") then
    local mag = (hit - v.Character.HumanoidRootPart.Position).Magnitude
    if mag < maxdis then
        maxdis = mag
        target = v
    end
end
end
return target
end


local target1 = getcp()

spawn(function()
game:GetService("RunService").RenderStepped:Connect(function()
target1 = getcp()
if target1 and target1.Character and (getgenv().highlight or getgenv().killaurahigh) then
    local hi = Instance.new("Highlight", target1.Character)
    game.Debris:AddItem(hi, 0.1)
end
end)
end)
local lad = {"Head", "UpperTorso", "HumanoidRootPart", "RightUpperLeg", "RightUpperArm", "RightLowerLeg", "RightLowerArm", "RightHand", "RightFoot", "LowerTorso", "LeftUpperLeg", "LeftUpperArm", "LeftLowerLeg", "LeftLowerArm", "LeftHand"}
spawn(function()
    if hookmetamethod then
        local saimh;
        saimh = hookmetamethod(game, "__namecall", function(Self, ...)
            local method = getnamecallmethod():lower()
            local args = {...}
            if tostring(method) == "findpartonray" and getgenv().saim and target1.Character and target1 and tostring(getfenv(0).script) == "GunScript_Local" then
                local targetPosition = target1.Character["Head"].Position
                if getgenv().randomredire then
                    targetPosition = target1.Character[lad[math.random(1, #lad)]].Position
                end
                local origin = args[1].Origin
                if getgenv().wallbang then

                end
                local direction = (targetPosition - origin).Unit
                args[1] = Ray.new(origin, direction * 1000)
                return saimh(Self, table.unpack(args))
            end
            return saimh(Self, ...)
        end)
    end
end)



getgenv().selectedBodyPart = "Head"
getgenv().kreek = false

function setupsilentokay(tool)
if tool:WaitForChild("Setting") and getgenv().kreek then
tool.Activated:Connect(function()
    print("activated")
    local toilet = 20
    if getgenv().kreek then
        print("activated 2")
        local secondtarget = closestopp()   
        if secondtarget and secondtarget.Character then
            print("[DEBUG] Target found:", secondtarget.Name)

            if secondtarget.Character and secondtarget.Character:FindFirstChild("Humanoid") then
                local targetRoot = secondtarget.Character.HumanoidRootPart
                
                if not getgenv().wallbang then
                    local rayDirection = (targetRoot.Position - RootPart().Position).Unit * 1000
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

                    local raycastResult = workspace:Raycast(RootPart().Position, rayDirection, raycastParams)
                    if raycastResult and not raycastResult.Instance:IsDescendantOf(secondtarget.Character) then
                        return
                    end
                end

                if getgenv().randomredire then
                    local randomPart = lad[math.random(1, #lad)]
                    print("[DEBUG] Damaging random part:", randomPart)
                    dmg(secondtarget, randomPart, toilet)
                    Library:Notify(string.format("[ProximityHub] - Damaged %s (%s) for %d HP", secondtarget.Name, randomPart, toilet), 5)
                else
                    print("[DEBUG] Damaging selected part:", getgenv().selectedBodyPart)
                    dmg(secondtarget, getgenv().selectedBodyPart, toilet)
                    Library:Notify(string.format("[ProximityHub] - Damaged %s (%s) for %d HP", secondtarget.Name, getgenv().selectedBodyPart, toilet), 5)
                end
            else
                print("[DEBUG] Invalid target character or humanoid.")
            end
        else
            secondtarget = closestopp()
            print("[DEBUG] No valid target found.")
        end
    end
end)
end
end

function randomRGB()
return Color3.fromRGB(
Random.new():NextInteger(0, 255),
Random.new():NextInteger(0, 255),
Random.new():NextInteger(0, 255)
)
end

-- Extras
Extra:AddLabel("Patched Kill Aura, Being Manually Banned By Report So Removed.!")
--[[
Extra:AddToggle("Killaura", {
    Text = 'Killaura',
    Default = false,
    Tooltip = 'Killaura Gun required',
    Callback = function(Value)
        getgenv().auraenabled = Value
        while getgenv().auraenabled and task.wait(getgenv().cooldown) do
            pcall(function()
                if getgenv().beam then
                    if game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool") and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("GunScript_Local") then
                        local target = target1
                        if target and target.Character then
                            local randomDelay = math.random(1, 3) / 10
                            task.wait(randomDelay)
                            
                            local hitParts = {"Head", "Torso", "HumanoidRootPart"}
                            local randomHitPart = hitParts[math.random(1, #hitParts)]
                            
                            local randomDamage = getgenv().damage + math.random(-5, 5)
                            
                            if math.random(1, 100) <= 30 then
                                local randomOffset = Vector3.new(
                                    math.random(-2, 2),
                                    math.random(-2, 2),
                                    math.random(-2, 2)
                                )
                                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = 
                                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame + randomOffset
                            end

                            local part = Instance.new("Part", workspace)
                            part.Size = Vector3.new(0.2, 0.2, (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - target.Character.HumanoidRootPart.Position).Magnitude)
                            part.Anchored = true
                            part.CanCollide = false
                            part.Material = Enum.Material.Neon
                            part.Color = getgenv().rainbowbeam and randomRGB() or getgenv().color

                            local midpoint = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position + target.Character[randomHitPart].Position) / 2
                            part.Position = midpoint
                            part.CFrame = CFrame.new(midpoint, target.Character[randomHitPart].Position)

                            task.wait(0.1)
                            part:Destroy()

                            dmg(target, randomHitPart, randomDamage)
                        end
                    end
                end
            end)
        end
    end
}):AddKeyPicker('KillauraKey', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Activates Killaura',
    NoUI = false,
})

Extra:AddToggle("KillAllPlus", {
    Text = 'Kill All',
    Default = false,
    Tooltip = 'Kill All (Gun Required)',
    Callback = function(Value)
        getgenv().killallplus = Value
        while getgenv().killallplus and task.wait(getgenv().cooldown) do
            pcall(function()
                local player = game.Players.LocalPlayer
                local tool = player.Character and player.Character:FindFirstChildWhichIsA("Tool")
                if tool and tool:FindFirstChild("GunScript_Local") then
                    local randomDelay = math.random(1, 3) / 10
                    task.wait(randomDelay)
                    
                    local players = game.Players:GetPlayers()
                    for i = #players, 1, -1 do
                        local j = math.random(i)
                        players[i], players[j] = players[j], players[i]
                    end
                    
                    for _, target in ipairs(players) do
                        if target ~= player 
                            and target.Character 
                            and target.Character:FindFirstChild("HumanoidRootPart") 
                            and target.Character:FindFirstChild("Humanoid") 
                            and target.Character.Humanoid.Health > 0 
                            and (not target.Team or target.Team ~= player.Team) then

                            local head = target.Character:FindFirstChild("Head")
                            if head and (not _G.wallCheck or not Check(head)) then
                                local hitParts = {"Head", "Torso", "HumanoidRootPart"}
                                local randomHitPart = hitParts[math.random(1, #hitParts)]
                                local randomDamage = getgenv().damage + math.random(-5, 5)
                                
                                if math.random(1, 100) <= 30 then
                                    local randomOffset = Vector3.new(
                                        math.random(-2, 2),
                                        math.random(-2, 2),
                                        math.random(-2, 2)
                                    )
                                    player.Character.HumanoidRootPart.CFrame = 
                                        player.Character.HumanoidRootPart.CFrame + randomOffset
                                end

                                local humanoid = target.Character.Humanoid
                                local hpBefore = humanoid.Health

                                dmg(target, randomHitPart, randomDamage)

                                if humanoid and humanoid.Health <= 0 and hpBefore > 0 then
                                    Library:Notify("Killed " .. target.Name, 4)
                                end
                                
                                task.wait(math.random(1, 5) / 100)
                            end
                        end
                    end
                end
            end)
        end
    end
}):AddKeyPicker('Kill All', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Activates Kill All',
    NoUI = false,
})



Extra:AddToggle("KillAuraHighlight", {
	Text = 'Highlight Target',
	Default = false,
	Callback = function(Value)
		getgenv().killaurahigh = Value
	end
}):AddKeyPicker('HighlightKey', {
	Default = '',
	SyncToggleState = true,
	Mode = 'Toggle',
	Text = 'Activates Highlight',
	NoUI = false,
})

Extra:AddInput('KillAuraHitPart', {
	Default = 'Head',
	Numeric = false,
	Finished = true,
	Text = '[HitPart]',
	Placeholder = 'Head',
	Callback = function(Value)
		getgenv().hitpart = tostring(Value)
	end
})

Extra:AddInput('KillAuraDamage', {
	Default = '100',
	Numeric = true,
	Finished = true,
	Text = '[Damage]',
	Placeholder = '100',
	Callback = function(Value)
		getgenv().damage = tonumber(Value)
	end
})

Extra:AddInput('KillAuraCooldown', {
	Default = '0',
	Numeric = true,
	Finished = true,
	Text = '[Cooldown]',
	Placeholder = '0',
	Callback = function(Value)
		getgenv().cooldown = tonumber(Value)
	end
})]]
-- Silents
Silent:AddDivider()
Silent:AddLabel("Silent Aim Section")
Silent:AddToggle('Enable Silent Aim', {
    Text = 'Silent Aim',
    Default = false,
    Tooltip = nil,
    Callback = function(Value)
        if Value then
            if not hookmetamethod then
                Library:Notify("[ProximityHub] - Your executor doesn't support this!", 5)
                task.wait(0.5)
            end
        end
        getgenv().saim = Value
    end
}):AddKeyPicker('Silent Aim Toggle', {
    Default = '',
    SyncToggleState = true,
    Mode = 'Enable',
    Text = 'Activates Silent Aim',
    NoUI = false,
})

local function isSitting(playerChar)
    local humanoid = playerChar:FindFirstChildWhichIsA("Humanoid")
    return humanoid ~= nil and humanoid.Sit == true
end

local function updateHitboxes()
    if _G.Disabled then return end
    for _, v in ipairs(game:GetService('Players'):GetPlayers()) do
        if v ~= game:GetService('Players').LocalPlayer then
            pcall(function()
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = v.Character.HumanoidRootPart
                    
                    if isSitting(v.Character) then
                        local originalSize = hrp:FindFirstChild("OriginalSize")
                        if originalSize then
                            hrp.Size = originalSize.Value
                        else
                            hrp.Size = Vector3.new(2, 2, 1)
                        end
                        hrp.Transparency = 1
                        hrp.BrickColor = BrickColor.new("Medium stone grey")
                        hrp.Material = Enum.Material.Plastic
                        hrp.CanCollide = true
                        return
                    end
                    
                    if not hrp:FindFirstChild("OriginalSize") then
                        local originalSize = Instance.new("Vector3Value")
                        originalSize.Name = "OriginalSize"
                        originalSize.Value = hrp.Size
                        originalSize.Parent = hrp
                    end
                    
                    hrp.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                    hrp.Transparency = _G.UseCustomHitbox and _G.CustomHitboxTransparency or 0.7
                    hrp.BrickColor = _G.UseCustomHitbox and BrickColor.new(_G.CustomHitboxColor) or BrickColor.new("Mint")
                    hrp.Material = Enum.Material.ForceField
                    hrp.CanCollide = false
                end
            end)
        end
    end
end

Hitboxes:AddToggle('EnableHitbox', {
    Text = 'Enable Hitbox',
    Default = false,
    Callback = function(Value)
        _G.Disabled = not Value
        if not _G.Disabled then
            updateHitboxes()
        else
            for _, v in ipairs(game:GetService('Players'):GetPlayers()) do
                if v ~= game:GetService('Players').LocalPlayer then
                    pcall(function()
                        if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                            local hrp = v.Character.HumanoidRootPart
                            local originalSize = hrp:FindFirstChild("OriginalSize")
                            if originalSize then
                                hrp.Size = originalSize.Value
                                originalSize:Destroy()
                            else
                                hrp.Size = Vector3.new(2, 2, 1)
                            end
                            hrp.Transparency = 1
                            hrp.BrickColor = BrickColor.new("Medium stone grey")
                            hrp.Material = Enum.Material.Plastic
                            hrp.CanCollide = true
                        end
                    end)
                end
            end
        end
    end
})

Hitboxes:AddDropdown('Hitbox Type', {
    Values = {'Legit', 'Semi Legit', 'Rage'},
    Default = 1,
    Multi = false,
    Text = 'Hitbox Presets',
    Tooltip = 'Select hitbox preset',
    Callback = function(Value)
        _G.SelectedPreset = Value
    end
})

Hitboxes:AddButton('Apply Hitbox', function()
    if not _G.Disabled then
        if _G.SelectedPreset == 'Legit' then
            _G.HeadSize = 3.5
        elseif _G.SelectedPreset == 'Semi Legit' then
            _G.HeadSize = 10
        elseif _G.SelectedPreset == 'Rage' then
            _G.HeadSize = 20
        end
        updateHitboxes()
    end
end)

Hitboxes:AddSlider('HitboxSlider', {
    Text = 'Hitbox Size',
    Min = 1,
    Max = 50,
    Rounding = 1,
    Default = 5,
    Callback = function(val)
        _G.HeadSize = val
        updateHitboxes()
    end
})

game.Players.PlayerAdded:Connect(function(player)
    if player ~= game:GetService('Players').LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            local hrp = char:WaitForChild("HumanoidRootPart")
            local originalSize = Instance.new("Vector3Value")
            originalSize.Name = "OriginalSize"
            originalSize.Value = hrp.Size
            originalSize.Parent = hrp
        end)
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    updateHitboxes()
end)

Hitboxes:AddSlider('CustomHitboxTransparency', {
    Text = 'Hitbox Transparency',
    Default = _G.CustomHitboxTransparency,
    Min = 0.01,
    Max = 1,
    Rounding = 1,
    Callback = function(Value)
        _G.CustomHitboxTransparency = Value
        updateHitboxes()
    end
})

Hitboxes:AddLabel("Hitbox Color"):AddColorPicker('CustomHitboxColor', {
    Text = 'Hitbox Color',
    Default = Color3.fromRGB(0, 255, 0), 
    Callback = function(Color)
        _G.CustomHitboxColor = Color
        updateHitboxes()
    end
})

-- GunModss
GunMods:AddButton('Infinite Ammo', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).LimitedAmmoEnabled = false
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).MaxAmmo = 9e9
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).AmmoPerMag = 9e9
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).Ammo = 9e9
end)

GunMods:AddButton('No Recoil', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).Recoil = 0
end)

GunMods:AddButton('Automatic Gun', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).Auto = true
end)

GunMods:AddButton('No Fire Rate', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).FireRate = 0
end)

GunMods:AddButton('Inf Damage', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).BaseDamage = 9e9
end)
GunMods:AddButton('Fast Reload', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).ReloadTime = 0.01
end)

GunMods:AddButton('Gun Knockback', function()
    require(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Setting).Knockback = 20
end)


local madeByLabel = MenuGroup:AddLabel('Made by: dragoniets')

MenuGroup:AddButton('Copy Discord', function() 
    setclipboard('https://discord.gg/proximityhub')
    Library:Notify("Discord link copied!", 3)
end)

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

local gameIdInput = MenuGroupRight:AddInput('GameID', {
    Text = 'Game ID',
    Default = '',
    Numeric = true,
    Finished = false,
    Callback = function(Value)
        gameIdInput:SetValue(Value)
    end
})

MenuGroupRight:AddButton('Join Game', function()
    if gameIdInput.Value ~= "" then
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, gameIdInput.Value, game:GetService("Players").LocalPlayer)
    else
        Library:Notify("Please enter a valid Game ID", 3)
    end
end)

MenuGroupRight:AddButton('Copy Join Code', function()
    local joinCode = game:GetService("TeleportService"):GetLocalPlayerTeleportData()
    if joinCode then
        setclipboard(joinCode)
        Library:Notify("Join code copied!", 3)
    else
        Library:Notify("No join code available", 3)
    end
end)

MenuGroupRight:AddButton('Rejoin Server', function()
    game:GetService("TeleportService"):Teleport(game.PlaceId, game:GetService("Players").LocalPlayer)
end)

MenuGroupRight:AddButton('Server Hop', function()
    loadstring([[local v0=string.char;local v1=string.byte;local v2=string.sub;local v3=bit32 or bit ;local v4=v3.bxor;local v5=table.concat;local v6=table.insert;function v7(v15,v16) local v17={};for v23=1, #v15 do v6(v17,v0(v4(v1(v2(v15,v23,v23 + 1 )),v1(v2(v16,1 + (v23% #v16) ,1 + (v23% #v16) + 1 )))%256 ));end return v5(v17);end local v8=game:GetService(v7("\229\198\215\32\246\180\213\10\226\198\201\51\239\184\194","\126\177\163\187\69\134\219\167"));local v9=game:GetService(v7("\11\217\62\213\207\38\223\60\204\255\38","\156\67\173\74\165"));local v10=game:GetService(v7("\4\187\72\15\185\52\85","\38\84\215\41\118\220\70"));local v11=game.PlaceId;if  not v11 then local v24=791 -(368 + 423) ;while true do if (v24==(0 + 0)) then warn(v7("\96\26\35\17\251\121\50\98\27\237\16\24\43\30\176\16\55\48\23\190\73\25\55\82\236\69\24\44\27\240\87\86\54\26\247\67\86\43\28\190\98\25\32\30\241\72\86\17\6\235\84\31\45\77","\158\48\118\66\114"));return;end end end local v12=AllIDs or {} ;local v13="";function v14() local v18=18 -(10 + 8) ;local v19;local v20;local v21;while true do if (v18==(997 -(915 + 82))) then v19=v7("\163\48\4\38\96\255\180\228\35\17\59\118\182\181\185\43\18\58\124\189\181\168\43\29\121\101\244\180\172\37\29\51\96\234","\155\203\68\112\86\19\197")   .. v11   .. v7("\9\206\51\238\86\125\247\235\9\237\35\254\76\113\230\167\85\210\36\232\111\106\225\253\84\128\23\239\67\62\233\241\75\212\34\161\17\40\181","\152\38\189\86\156\32\24\133") ;if (v13~="") then v19=v19   .. v7("\186\84\178\84\239\88\181\27","\38\156\55\199")   .. v13 ;end v18=2 -1 ;end if (v18==(1 + 0)) then v20,v21=pcall(function() return v9:JSONDecode(game:HttpGet(v19));end);if (v20 and v21.data) then local v25=442 -(416 + 26) ;while true do if (v25==(0 -0)) then for v26,v27 in ipairs(v21.data) do if ((v27.playing<v27.maxPlayers) and  not table.find(v12,v27.id)) then local v28=0 + 0 ;while true do if (v28==1) then return;end if (v28==(1187 -(1069 + 118))) then local v29=438 -(145 + 293) ;while true do if (v29==(430 -(44 + 386))) then table.insert(v12,v27.id);v8:TeleportToPlaceInstance(v11,v27.id,v10.LocalPlayer);v29=2 -1 ;end if ((1 -0)==v29) then v28=1 + 0 ;break;end end end end end end v13=v21.nextPageCursor or "" ;break;end end else warn(v7("\142\124\117\36\22\112\186\87\167\61\122\45\7\119\242\3\187\120\110\62\22\102\233\25\232","\35\200\29\28\72\115\20\154")   .. tostring(v21) );end break;end end end while v13~=nil  do local v22=0 -0 ;while true do if (v22==(772 -(201 + 571))) then v14();wait(1 + 0 );break;end end end]])()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)


ThemeManager:SetFolder('ProximityHub')
SaveManager:SetFolder('ProximityHub/Tha Bronx 3')

SaveManager:BuildConfigSection(Tabs['Settings'])

ThemeManager:ApplyToTab(Tabs['Settings'])


SaveManager:LoadAutoloadConfig()

loadstring(game:HttpGet("https://raw.githubusercontent.com/selciawashere/ProximityHub/refs/heads/main/SaveManager",true))()
local menuVisible = false
local menuWindow = MenuGroup.Parent

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.End then
            menuVisible = not menuVisible
            if menuVisible then
                menuWindow.Visible = true
            else
                menuWindow.Visible = false
            end
        end
    end
end)
